# Prueba de desempeño: Fases de Desarrollo y Modelos de Ciclo de Vida
Utilizando referencias válidas (incluirlas como parte de la documentación) realiza las siguientes reflexiones. Es importante que los argumentos que presentes estén fundamentados con las referencias utilizadas. Cada reflexión debe contar con referencias.

---
# Unidad 2

### Reflexiona sobre 3 habilidades técnicas asociadas a la fase de Requerimientos. Indica su importancia dentro del ciclo de Ingeniería de Requerimientos. Incluye argumentos de tu selección. Proporciona un ejemplo basado en la experiencia del proyecto en equipo que están desarrollando.

#### Comunicación: 
La comunicación es importante a la hora del desarrollo de un proyecto, pues la creatividad se ve expresada mediante el uso correcto del lenguaje, desde los colegas o compañeros de equipo al momento de discutir el funcionamiento de un programa, o la buena comunicación que se debe mantener con el cliente para convencerlo de llevar a cabo el proyecto. Es una herramienta necesaria para un ingeniero de carácter multidisciplinario, permitiendo gestionar bien la organización del equipo, simplificar el lenguaje de comunicación (expresar ideas complejas en palabras simples), por otra parte, el dominio de algún idioma externo a nuestra lengua nativa como lo puede ser el inglés, puesto que la mayoría de palabras de marketing o términos de programación se encuentran en este idioma. (Chávez y Carrillo, 2005, p.9).

Con antes mencionado en cuenta, al momento de aplicarlo en el desarrollo de requerimientos, es bueno dejar en claro cuáles serán los objetivos a cumplir, la gestión del tiempo y las herramientas que se emplearán, en caso de no ponerse de acuerdo, el cliente y el grupo de desarrollo, se puede presentar un proyecto que no cumpla con las expectativas del comprador, en este caso los recursos y tiempo se vieron desperdiciados, también al momento de reunirse entre programadores es bueno mantener una comunicación óptima, pues permite mejor organización de tareas, por ende, un trabajo más rápido y efectivo

**Ejemplo:** El grupo de desarrollo de este proyecto realizó conferencias con el objetivo de poder organizar la importancia de requerimientos y cuáles serían los más fundamentales, por el hecho de no conocernos al principio fue difícil expresar las ideas con claridad, sin embargo mientras iban progresando los días y avanzaban las entregas, era más fácil poder expresar cuáles eran las condiciones que queríamos para la aplicación y sus herramientas.

#### Pensamiento complejo
Según Zepeda-Hurtado, et. al (2019) esta cualidad ayuda a entender conceptos, la capacidad de inferir una resolución mediante lógica, realizar soluciones creativas partiendo de nuevas ideas y descomponiéndolas, para hallar algún método. Esta habilidad es muy útil para el desarrollo de algún software, debido a que debemos estar dispuestos a adquirir nuevos conocimientos, como lo pueden ser ideas de marketing, los diferentes tipos de gestión de proyectos, o al momento de desarrollar un programa para algún ámbito externo a nuestros conocimientos, tenemos que adentrarnos al aprendizaje de nuevos temas para poder desarrollar herramientas que entiendan la necesidad del software, de esta forma mejorando su desempeño

**Ejemplo:** Para poder desarrollar nuestra aplicación y gestionar mejor nuestras ideas y tiempo, tuvimos que entender y aprender diferentes sistemas de organización de proyectos como lo es el scrum, con el objetivo de tener un mejor desempeño al momento de la realización de las tareas, de otra forma también intentamos entender conceptos nuevos de marketing o programación, como lo puede ser el uso de los repositorios y su funcionamiento, en la parte de requerimientos sirvió para saber implementar qué herramientas serían vitales para el funcionamiento óptimo de la app



#### Comprensión lectora
Según Zepeda-Hurtado, et. al. (2019) La comprensión lectora es la capacidad de poder procesar la información escrita, pero también es necesaria para poder expresarla en algún documento, esta cualidad es necesaria para el desarrollo de un proyecto pues el plasmar las ideas y mostrar los avances en un escrito, se requiere de un buen nivel de redacción y sintaxis, un buen uso del léxico y la capacidad de poder resumir la información de textos o manuales, generalmente se suele ejercer sólo la resolución de problemas, sin embargo al momento de consultar información de alguna lectura, requerimos de la capacidad de interpretar, entender y expresar un escrito. (p. 65)

**Ejemplo:** Para el desarrollo del proyecto tuvimos que desarrollar nuestra capacidad lectora para poder entender y comprender las diferentes definiciones, poder expresar nuestros requerimientos y que queden claros sus funcionamientos, con el objetivo de que nuestras ideas e indicaciones sean precisas, y lleguen a la comprensión del usuario


### Explica de forma clara la diferencia entre Especificación de Casos de Uso vs Historias de Usuario. Adicionalmente indica en qué casos se recomiendan el uso de cada una de estas herramientas. Proporciona un ejemplo basado en la experiencia del proyecto en equipo que están desarrollando.

La mayoría de problemas en un proyecto de software se debe a la mala coordinación del manejo de los requerimientos esto se debe ya que hay una mala comunicación entre usuario y desarrollador, siendo mayormente que el cliente no sepa lo que quiere o lo que realmente necesita, es por eso que para facilitar más esta validación de necesidades se usan las especificaciones de casos de uso.

- **Especificaciones de casos de uso:** esto se utiliza como una forma de ver cómo interactúa el usuario con nuestro programa sirviendo como una documentación para saber que se puede mejorar de acuerdo a las necesidades de nuestros usuarios, siendo necesariamente que sean lo más detallado y preciso posible ya que, entre menos detalle más será el margen de error que pueda haber en nuestro programa, esto viéndose desde la perspectiva externa al usuario .

**Ejemplo:** Publicación de productos
flujo:
1. El usuario vendedor selecciona el producto que decida vender
2. Añade las imágenes que publicará 
3. Añade una descripción al producto
4. Añade información de usuario 

**postcondición:** La publicación se verá reflejada en el feed de los usuarios.


En el caso de las historias de usuario son descripciones más cortas las cuales mencionan características del funcionamiento del sistema desde la perspectiva del usuario con el fin de 
comprender las necesidades de estos de manera más clara sirviendo como base para la planificación del software de acuerdo a lo que el usuario busca en la respectiva aplicación, pudiendo dividirlas en tareas de menor tamaño implementados en “sprints”. 

Un ejemplo de las historias de usuario podría ser en la parte del registro:

“Cómo usuario registrado, quiero poder elegir entre un método de confirmación de mi cuenta para tener un acceso más seguro.”

*“Las historias de usuario son parte de un enfoque ágil que ayuda a cambiar el enfoque de escribir sobre los requisitos a hablar sobre ellos. Todas las historias de usuario ágiles incluyen una oración escrita o dos y, más importante aún, una serie de conversaciones sobre la funcionalidad deseada.”* (Scrum Mexico, 2018).



### Selecciona un producto resultante de la etapa de diseño (Arquitectura, Base de Datos, Interfaz de Usuario, Procedimientos). Explica de forma clara y sintética algún método asociado al producto resultante. Proporciona un ejemplo basado en la experiencia del proyecto en equipo que están desarrollando.

#### Interfaces usuario

#### Modelo de objeto de interfaz

**1. Elaboración del lenguaje de patrones de interacción:**

- analizar el modelo de casos de uso 
- identificar los puntos de interacción usuario-aplicación 
elaborar un lenguaje de patrones incluyendo nombre, problema, contexto, solución y consecuencia. 

**2. Elaboración del Modelo Objeto de Interfaz:**

- Elaboración del lenguaje de patrones de interacción:
1. Se utiliza el modelo Objeto del Dominio como base.
2. Se aplica la rectificación de objetos del dominio necesarios en la interfaz.
3. Se crean nuevos objetos mediante la reificación de operaciones, y se define un instrumento de interacción para cada operación, actuando como mediador entre el usuario y el objeto en la interfaz.

**3. Construcción del Prototipo de Interfaz de Usuario:**

- Se basa en el análisis del Lenguaje de Patrones y el modelo Objeto de Interfaz.
Dependiendo de cómo se expresan las soluciones en los patrones de interacción:
- Si las soluciones son bosquejos de pantallas o descripciones, se crea un prototipo de baja fidelidad. Luego, se implementan las soluciones en un prototipo de alta fidelidad.
- Si las soluciones se expresan gráficamente con un diseño de interfaz utilizando el lenguaje de implementación del producto final, se considera prácticamente elaborado un prototipo de alta fidelidad.


#### Modelo SSOA

De acuerdo Schneiderman, B.,  El modelo Sintactico-semantico (SSOA) proporciona diferentes formas en las que un usuario pueda interactuar con un sistema. La diferencia entre las sintaxis y semántica se originó a través de la definición de compiladores separando la parte del análisis sintáctico siendo la parte del proceso de entrada de texto/comando de la parte semántica  siendo el proceso de interpretación. Los diseñadores igualmente pueden usar un modelo de sintáctico-semántico de acuerdo al conocimiento del usuario siendo el conocimiento sintáctico la comprensión de los detalles de los usos de los dispositivos, mientras que el semántico abarca información relacionada con la aplicación como el uso general de los sistemas interactivos.  

Schneiderman, B. (1992). “El modelo Sintáctico-Semántico del conocimiento del usuario (SSOA) provee un marco de definición sobre las diferentes formas y grado de conocimiento que un usuario puede emplear al interactuar con un sistema. La distinción entre las sintaxis y semántica surgió a partir de la definición de compiladores, separando el proceso de compilación de la entrada de texto o comando, denominado análisis sintáctico, del proceso de interpretación del mismo, denominado análisis semántico. Los diseñadores de los sistemas interactivos también pueden contar con un modelo sintáctico semántico aplicado al conocimiento del usuario. Como se explicó en la fase de requerimientos, el conocimiento sintáctico se refiere al entendimiento de detalles dependientes al uso de los dispositivos. El conocimiento semántico incluye información conceptual concerniente a la aplicación -objetos y acciones del dominio de la tarea- y al uso general de los sistemas interactivos.”

- Etapa del diseño de la interfaz:

El diseñador de la interfaz ajusta el modelo del usuario y los aspectos de diseño, mientras que las modificaciones en la funcionalidad se comunican al diseñador del sistema. 

En cada paso, se revisa, rediseña y reevalúa la interfaz, considerando costos y beneficios. Puede surgir nueva información desconocida en pasos anteriores, afectando las decisiones de diseño. Adelantarse a las etapas siguientes, investigando aspectos como hardware y software, resulta útil para determinar los costos y accesibilidad del diseño. En última instancia, el proceso del diseñador es iterativo, refinando los pasos actuales y pasados, e incorporando conocimientos de etapas futuras que influyen en las decisiones actuales.


### Investiga sobre un método o técnica que permita incluir pruebas de forma efectiva en el proceso de desarrollo. ¿A partir de qué etapa pueden ser consideradas las pruebas?. Proporciona un ejemplo basado en la experiencia del proyecto en equipo que están desarrollando.

#### Métodos de prototipos evolutivos

Un modelo el cual permita la inclusión de pruebas constantes es el modelo de prototipos evolutivos, pues la UNAM (2012) define a este proceso como “la creación de una implementación parcial de un sistema, para el propósito explícito de aprender sobre los requerimientos del sistema”. Los prototipos se empiezan a crear a partir de la segunda fase principal del modelo y se busca crearlos de la manera más rápida posible, para después presentarlos a los clientes o representantes, los cuales lo probarán y retroalimentarán, devolviendo los errores que encuentren y  posteriormente el equipo desarrollador corrija estos errores para nuevamente presentar hasta haber cubierto los puntos débiles o fallas totales del sistema. 
En su libro electrónico “Metodologías y Procesos de Análisis de Software” la UNAM (2012) describe el proceso del modelo en 5 fases principales:
1. **Investigación preliminar:** Esta fase se divide a su vez en 3 fases: clasificación de requerimientos, estudio de factibilidad y la aprobación del requerimiento. Estas 3 sub-fases tienen como meta general determinar la problemática, el ámbito, identificar una idea general para la solución del problema y determinar si el sistema es o no factible de realizar
2. **Definición de requerimientos del sistema:** Una vez concluida la fase anterior y haberse determinado que el proyecto es viable, se avanza con la fase de la definición de los requerimientos, la cual a su vez se divide en otras 5 sub-fases. Es en esta fase donde comienzan las pruebas constantes para realizar el código; la fase comenzará con el análisis grueso y especificación; en esta primera sub-fase se crea el primer boceto del prototipo del sistema, luego pasamos a la sub-fase diseño y construcción, fase donde el boceto pasa a un software funcional listo para presentar como primera entrega. Le sigue la sub-fase de evaluación, parte donde el código se presenta a los usuarios para que ellos retroalimenten y el equipo desarrollador presente el código corregido. Casi para terminar sub-fase está la modificación, que es donde el código entra en corrección según los comentarios de los usuarios propuestos en la sub-fase anterior. La fase termina con el término, que es la sub-fase donde el código se presenta en su gran mayoría sin errores y con el visto bueno de los usuarios.
3. **Diseño técnico:** Es en esta fase donde se crea una interfaz para el programa en base a los estándares de la marca. La fase se centrará únicamente en crear un diseño detallado y sofisticado para el usuario en general; como adicional igual se crea una documentación que especifica las funciones del programa y lo necesario para realizar cualquier tipo de mantenimiento al software.
4. **Desarrollo y pruebas:** En esta fase ya se han tenido las pruebas suficientes para tener un programa completo, con un diseño digno de salir al mercado y una funcionalidad cómoda y correcta para el usuario, por lo que únicamente se realizarán unas últimas pruebas para confirmar que el código funcione en su totalidad, y en caso de presentarse algún inconveniente, corregirlo inmediatamente y poder entregar el código.
5. **Operación y mantenimiento:** Es la última fase del modelo; en esta fase los errores son mínimos y el programa ya se encuentra entregado al usuario, La fase queda únicamente como método preventivo en caso de fallas y un mantenimiento al software para evitar su caída.

   
**Ejemplo:** Al momento de entrar a la fase de diseño y empezar a trabajar con diagramas de casos de uso y wireframes nos guíamos únicamente por nuestra propia percepción, por lo que los wireframes no fueron lo más óptimos y cómodos para los usuarios; a raíz de un análisis del equipo nos metimos al papel de usuarios y pensamos en las funciones básicas que realizan los wireframes y la experiencia que estos generan; fue gracias a este análisis que nos dimos cuenta que no eran adecuados y empezamos una fase de prueba y error, creando, descartando y mejorando bocetos de diseños, llegando así hasta los últimos bocetos funcionales que dejamos como correctos.  Esto nos dejó una enseñanza a menor escala de lo que sucede en el modelo, sin embargo, se considera como una buena aproximación hacia lo que normalmente se trata con este modelo de prototipos.



### Utilizando fuentes confiables, establece las habilidades/conocimientos/competencias míninas indispensables que un Ingeniero de Software debe incluir en su formación académica para el desarrollo de Aplicaciones de Software Seguras.

Vemos pertinente documentar nuestra reflexión con información puntual obtenida de autoridades sobre el tema, como lo es el Instituto de Ingenieros Eléctricos y Electrónicos. Sociedad de computación (IEEE-CS)  y la  Asociación de Maquinaria de Computación (ACM) . Asimismo, hemos rescatado matices importantes: la relación entre habilidades, conocimientos, y competencias; safety y security; o Ingeniería de software y ciberseguridad como disciplinas separadas. Nuestro escrito, que en gran parte es una investigación, consta de 2 secciones; en las definiciones, la argumentación es menor o inexistente. Nos apoyamos en ellas para introducir con propiedad conceptos posteriormente tratados. Dicha sección enriquece el trabajo para un posterior repaso. 

#### Definiciones

**Seguridad de aplicaciones:** (AppSec) son los procesos, prácticas y herramientas que se utilizan para identificar, reparar y proteger contra vulnerabilidades en las aplicaciones, durante todo el ciclo de vida de desarrollo de software (SDLC). La seguridad de las aplicaciones implica una amplia gama de herramientas y metodologías, pero todas tienen el mismo objetivo: identificar debilidades y vulnerabilidades y corregirlas antes de que puedan ser explotadas. (Synopsis, s.f.).

**Ingeniería de software:** (IS) es una disciplina de ingeniería que se centra en el desarrollo y uso de métodos rigurosos para diseñar y construir artefactos de software que realizarán de manera confiable tareas específicas. (ACM y IEEE-CS, 2020, p.29).

**Ciberseguridad:** es el área relacionada con la informática que se enfoca en la protección de la infraestructura computacional y todo lo vinculado con la misma, y especialmente la información contenida en una computadora o circulante a través de las redes de computadoras. Es un campo de estudio altamente interdisciplinario. (ACM y IEEE-CS, 2020, p.27).

*En el 2015, La ANIEI (Asociación Nacional de Instituciones de Educación en Tecnologías de Información) la reconoció como disciplina independiente* (Rodriguez et al, p.3).


**Competencia:** constituye una perspectiva ampliada de la educación que aumenta el conocimiento (saber qué) con su hábil aplicación (saber cómo), motivado por un propósito (saber por qué) para realizar una tarea, un resultado de valor. 

*El entrelazamiento de las dimensiones de la competencia (conocimientos, habilidades y disposiciones) ofrece un vocabulario completo con el cual describir un plan de estudios que incluya los objetivos de aprendizaje naturales para el profesor, el estudiante y los respectivos profesión a la que la empresa educativa aspira a servir.* (ACM y IEEE-CS, 2020,  p.79).

**Conocimiento:** (como el conjunto de conocimientos). Información aprendida sobre un área del saber. (ACM y IEEE-CS, 2020, p.79).

**Habilidad:** se define como  el conocimiento aplicado en situaciones y entornos, con un nivel particular de competencia necesaria para una práctica exitosa. La habilidad es el conocimiento aplicado hábilmente. (ACM y IEEE-CS, 2020, p.79).

**Safety:** se refiere a estar protegido de quien causa daño. Es la condición de estar seguro contra amenazas tanto intencionadas como no intencionadas. (TFT, 2020).

*En IS, la safety del código garantiza la confiabilidad.* (Foster S. 2020).

**Security:** sugiere proteger a algo contra actividades criminales externas o amenazas que puedan inducir daño. El término se centra en los factores externos deliberados que tienen como objetivo causar problemas. (TFT, 2020).
 
*En IS, la security del código previene ataques.* (Foster S. 2020).

#### Competencias

#### Ingeniería de software incluye seguridad
Una cuestión a considerar por el estudiante de ingeniería de software, es si su disciplina incluye el dominio de competencias relacionadas a la seguridad. Como hemos mencionado anteriormente, la  ciberseguridad ya ha sido establecida como una disciplina por sí misma; por tanto, ¿Es necesario que el estudiante/profesionista de IS sea competente en eso? ¿Qué tan competente es mínimamente necesario que sea para poder desarrollar software y aplicaciones seguras? A la primera pregunta, podemos inferir que sí, es necesario que el desarrollador de software domine algo de seguridad de aplicaciones, pero ¿Qué tanto? En busca de información que conteste a la pregunta, vamos a los reportes de las asociaciones con autoridad sobre el tema, que han estandarizado definiciones e incluso competencias mínimas. En el reporte de IEEE-CS con ACM (2020), en la definición de ingeniería de software como disciplina se enuncia: *El fuerte enfoque de la ingeniería de software es sobre el diseño de sistemas de software fiables, dignos de confianza, seguros y utilizables. Los ingenieros a menudo se aplican a sistemas a gran escala con alta confiabilidad y requisitos de seguridad.* (p.29). La definición menciona a la seguridad como una característica que debe tener el producto desarrollado por el ingeniero de software.

**La lista de las competencias**

Para conocer las competencias que el ingeniero de software debe tener relacionadas a la seguridad, podemos consultar el reporte conjunto de ANIEI y CONAIC (2017). Según dichas asociaciones, una competencia que el ingeniero de software debe tener es: *Establece mecanismos de seguridad. Crea o propone métodos y estrategias para evaluar la seguridad y la selección de los criterios que eviten vulnerabilidades en seguridad del software.* (p.5).
.
Podemos comprobar que dichas asociaciones consideran la seguridad como una competencia que el Ingeniero de software debe dominar. No amplían más acerca de las competencias de seguridad en su informe del 2017, sin embargo, podemos estar seguros que la seguridad está considerada como una competencia mínima, fundamental, que sin duda un egresado del nivel licenciatura debe tener.
El IEEE-CS y ACM (2020) son más específicos. Incluyen 11 competencias que determina como indispensables específicamente en IS:

#### Protección (safety) del software
1. Describir las principales actividades relacionadas con el desarrollo de sistemas de software, que involucran preocupaciones de seguridad (actividades relacionadas a requerimientos, diseño, construcción y calidad).
2. Crear y verificar listas preliminares de peligros; realizar análisis de peligros y riesgos, identificar requisitos de seguridad.
3. Implementar y verificar soluciones de diseño, utilizando prácticas seguras de diseño y codificación, para garantizar que se mitiguen los peligros, y se cumplan los requisitos de seguridad.
4. Ser consciente de las consecuencias del desarrollo de software inseguro, es decir, el efecto negativo en quienes usan o reciben servicios del software.

#### Seguridad (security) del software
1. Aplicar el modelo de ciclo de vida de seguridad seleccionado del proyecto (por ejemplo, Microsoft SDL), como miembro colaborador de un equipo de proyecto.
3. Identificar los requisitos de seguridad aplicando el método de requisitos de seguridad seleccionado, como miembro contribuyente de un equipo de proyecto de software.
4. Incorporar requisitos de seguridad en la arquitectura, el diseño detallado y de alto nivel, como miembro contribuyente de un equipo de proyecto de software. 
5. Desarrollar software utilizando estándares de codificación segura.
6. Ejecuta casos de prueba específicos de seguridad.
7. Adherirse al proceso de desarrollo de software del proyecto, como miembro colaborador de un equipo de proyecto de software.
8. Desarrollar software que respalde los objetivos de calidad del proyecto y cumpla con los requisitos de calidad. (p. 120).

Podemos notar que dichas competencias, como es de esperarse, de alguna forma son aplicables al desarrollo de aplicaciones seguras. Por tanto, se espera que todo Ingeniero en software las domine. Probablemente al trabajar en un desarrollo complemente sus habilidades con la de ingenieros de otras disciplinas, pero se espera que él esté capacitado en seguridad. 




---
# Unidad 3
### Asumiendo que los valores descritos en el acuerdo del "Manifiesto para el desarrollo ágil desoftware", causan conflicto en el proceso de desarrollo reflexione y describa de manera clara posibles soluciones utilizando como base el proyecto que están desarrollando en equipo.

**1. Individuos e interacciones sobre procesos y herramientas:**

**Posible conflicto:** El empleo de herramientas o procesos que dicen facilitar el desarrollo del producto, a pesar de no saber usarlas o no estar bien informado acerca de su funcionalidad y nada más utilizarlos por ser “prácticos”. Esto puede perjudicar en la documentación y organización del producto.

**Solución:** Informarse acerca de los métodos y herramientas a utilizar, para poder escoger los que más convenien de acuerdo al equipo de trabajo, el producto a elaborar y muchos otros factores que pueden presentarse a la hora del proceso. 

**2. Software funcionando sobre documentación extensa:**

**Posible conflicto:** Elaboración de manera excesiva de documentación para cosas que son innecesarias o detallar demás en cada parte de la documentación siendo muy específicos hasta el punto de hacer una documentación exhaustiva.  

**Solución:** Documentar solo lo necesario y no entrar en detalles que pueden resultar innecesarios hasta cierto punto, y reducir la documentación a lo mínimo indispensable. 

**3. Colaboración con el cliente sobre negociación contractual:**

**Posible conflicto:** El no entender lo que el cliente/ usuario necesita, querer hacer todo sin ser objetivos o realizar cambios en el producto sin pasar por la aprobación del cliente. 

**Solución:** Establecer reuniones constantes con los clientes para comprender y validar los requisitos, para saber si se está logrando el objetivo o la visualización que el cliente tiene acerca del producto. En este caso nuestros clientes son los usuarios, así que  se pueden lanzar pruebas para comprobar la funcionalidad de la app o inclusive encuestas, trabajo de campo,etc. Para averiguar de manera más certera la fidelidad de lo que elaboramos. 

**4. Responder a cambios sobre seguir un plan:**

**Posible conflicto:** No realizar los requerimientos más óptimos, y al realizar los wireframes darse cuenta que las herramientas priorizadas no eran tan importantes 

**Solución:** Para evitar este problema, el equipo del proyecto se planteó los requerimientos y funciones generales para la aplicación, y al momento de ir desarrollando el proyecto, fuimos planteando nuevos requerimientos y nuevas herramientas. 

### Metodologías ágiles, principios de agilidad por metodología, y cómo se implementaría en nuestro proyecto:

**Crystal Clear:** Crystal es una metodología en la cual se establecen códigos de color como parte de la definición de la complejidad de la misma, si es más oscuro entonces el método es más pesado; cuánto más crítico es el sistema, más rigor se necesita. Además, crystal sugiere que se defina un color para cada proyecto en función de su criticidad y tamaño. No existe una metodología crystal en general, sino existe una metodología crystal para cada tipo de proyecto. (Rivadeneira, 2012).

**¿En qué consiste?** Crystal Clear consiste en una serie de prioridades, propiedades, estrategias, técnicas, ciclos, roles y artefactos. Las prioridades son mantener la seguridad del proyecto, desarrollar de forma eficiente y mantener la habitabilidad de las convenciones. Cockburn describe Crystal Clear no a través de las estrategias y técnicas que se deben aplicar, sino mediante una serie de propiedades claves. Esto lo hace motivado por el hecho de que en general los procedimientos que se sigan no necesariamente producen o cumplen las propiedades, y que otros procedimientos diferentes a los elegidos pueden producir esas propiedades para un equipo particular, por tanto, es más importante cumplir las propiedades que seguir determinados procedimientos. Por este motivo ninguna de las estrategias, técnicas o artefactos que Crystal Clear define es de uso obligado y pueden usarse cualquiera de las descritas en otras metodologías ágiles. (José Antonio, 2008).

Crystal Clear se centra en tres propiedades claves, que constituyen su núcleo: efectuar Entregas Frecuentes, que consiste en liberar código ejecutable y testeado a usuarios reales cada pocas semanas o meses; realizar una Mejora Reflexiva dedicando todo el equipo unido un pequeño tiempo para determinar qué está y qué no está funcionado, discutir qué se puede mejorar y qué se debe mantener; y el requerimiento de Crystal Clear en cuanto al tamaño del equipo y su ubicación física en un mismo local permite crear Comunicación Osmótica y que la información esté “flotando” en el ambiente, así el equipo puede obtenerla como si fuera por ósmosis. Otras propiedades importantes que pueden ser añadidas para incrementar la seguridad del proyecto son: crear Confianza Personal entre los miembros del equipo, mantener el foco en la tarea, tener Acceso Fácil a Usuarios Expertos y trabajar en un ambiente técnico con pruebas automáticas, administración de configuración e integración frecuente. (José Antonio, 2008).

**Proceso de la metodología Crystal Clear:**

- **Planificación del proyecto:** Se determinan los objetivos, el alcance, las prioridades y se hace una lista de funcionalidades. Se identifican los roles y se estima el esfuerzo.
- **Entregas frecuentes:** El proyecto se divide en iteraciones cortas de 2-4 semanas para entregar versiones utilizables del software con frecuencia.
- **Comunicación osmótica:** La comunicación entre el equipo es continua e informal. No hay reuniones formales, la información fluye de manera natural.
- **Propiedad personal:** Los miembros del equipo tienen libertad y responsabilidad para tomar decisiones sobre su trabajo. No hay jerarquías estrictas.
- **Equipo multifuncional:** El equipo tiene todas las habilidades necesarias para desarrollar, probar y desplegar el software por sí mismo.
- **Integración continua:** El software se integra y se compila de forma automática y continua para detectar errores tempranamente.
- **Refactorización:** Mejora continua del código existente para facilitar el mantenimiento y la evolución.
- **Funcionamiento incremental:** El sistema crece de forma iterativa añadiendo funcionalidades en cada entrega.
- **Fácil acceso a expertos:** Los miembros del equipo pueden consultar con expertos en cualquier momento para resolver dudas rápidamente.
- **Enfoque en la utilidad:** El software entregado debe ser útil y proporcionar valor al usuario lo antes posible.
  
Crystal es regida por principios (principios de agilidad) que hacen su utilización eficiente, entre los cuales se pueden mencionar:

- Cada proyecto necesita un grado diferente de compensación (Trade Off).
- Entre más pequeño sea el proyecto es mejor la forma de coordinación.
- Cada uno de los proyectos necesita diferentes medios de comunicación.
- Debe existir retroalimentación y comunicación efectiva, reduciendo así los problemas en entregas fallidas.
- Los puntos dulces aceleran el desarrollo, se debe de contar con personas capaces y dedicadas a su trabajo, que se preocupen por hacer las entregas a tiempo y conforme a lo que el cliente solicita.
- Equipos autoorganizados: Los miembros del equipo deciden la mejor forma de realizar el trabajo sin interferencia externa.
- Entregas incrementales: El producto se entrega en partes completas y utilizables en periodos cortos.
- Adaptación al cambio: Los requisitos pueden cambiar durante el proyecto y el equipo se adapta.
  
**Ventajas y desventajas de utilizar la metodología Crystal clear:**

**Ventajas:**

- Es muy ágil y flexible. Se adapta bien a proyectos con requisitos cambiantes.
- Promueve la comunicación y colaboración cercana entre el equipo de desarrollo y los usuarios/clientes.
- Los ciclos de desarrollo son cortos (de 2 a 4 semanas) permitiendo obtener retroalimentación temprana.
- No hay roles definidos, el equipo es auto-organizado.
- El software usable es priorizado sobre la documentación exhaustiva.
  
**Desventajas:**

- Requiere de un equipo altamente calificado y con experiencia para que la metodología funcione bien.
- La falta de documentación puede causar problemas a largo plazo de mantenimiento.
- Al no tener roles claros, puede haber confusión y falta de enfoque en el equipo.
- No es recomendable para proyectos muy grandes o complejos.
 - Depende mucho de la comunicación fluida entre el equipo, si esto falla, la metodología no funciona.
 - Puede ser difícil de adoptar para equipos acostumbrados a metodologías más estructuradas.


**Programación extrema (XP):**

 La programación extrema es una metodología que se basa en una serie de reglas y principios que se han utilizado a lo largo de toda la historia del desarrollo de software, aplicando conjuntamente cada una de ella de manera que creen un proceso ágil, en el que se le dé énfasis a las tareas que agreguen valor y quiten procedimientos que generan burocracia en el mismo. (Rivadeneira, 2012).
 
**¿En qué consiste?**

Los objetivos de XP son muy simples: la satisfacción del cliente. Esta metodología trata de dar al cliente el software que él necesita y cuando lo necesita. Por tanto, debemos responder muy rápido a las necesidades del cliente, incluso cuando los cambios sean al final de ciclo de la programación.

El segundo objetivo es potenciar al máximo el trabajo en grupo. Tanto los jefes de proyecto, los clientes y desarrolladores, son parte del equipo y están involucrados en el desarrollo del software. (Manuel Calero, 2003).

**Proceso de la metodología Programación Extrema (XP)**

- **Planificación:** Se crea una lista priorizada de historias de usuario que definen las funcionalidades deseadas. Se hace una planificación de versiones en ciclos cortos.
- **Diseño:** Solo se realiza el diseño necesario para las historias de la iteración actual. El diseño es simple y no hay documentación extensa.
- **Codificación:** Se implementa código para las historias de usuario priorizadas, escribiendo pruebas unitarias antes de codificar. Se integra código nuevo frecuentemente.
- **Pruebas:** Se crean pruebas unitarias para todo el código. También hay pruebas de aceptación definidas por el cliente. Se enfatiza la automatización de pruebas.
- **Integración continua:** El código se integra diariamente para detectar errores tempranos. Se mantienen construcciones estables del sistema.
- **Revisión de código:** Todo el código es revisado por otros programadores para mejorar la calidad.
- **Refactorización:** El código se refactoriza constantemente para eliminar duplicación y mejorar el diseño.
- **Entrega pequeña:** Versiones del sistema se entregan en ciclos cortos de 1-3 semanas, priorizando funcionalidades de mayor valor para el cliente.
- **Programación en parejas:** Todo el código es desarrollado por dos programadores en una misma computadora.
- **Propiedad colectiva:** Cualquier miembro del equipo puede cambiar cualquier parte del código en cualquier momento.
  
 La programación extrema se engloba en doce principios de agilidad básicos, los cuales a su vez se agrupan en cuatro categorías grandes, entre ellas se pueden mencionar:

- Retroalimentación a Escala Fina, en esta fase se encuentran diversos principios como los de realización de pruebas, proceso de planificación, el cliente en el sitio y programación en parejas.
- Proceso Continuo en lugar de por lotes, permite la integración continua, refactorización (Evaluar el diseño del sistema a lo largo de todo el proyecto y codificar si es necesario) y entregas pequeñas.
- Entendimiento compartido, en esta categoría se definen criterios como el de crear un diseño fácil, las tarjetas CRC (Clase, Responsabilidad y Colaboración) y la creación de la metáfora del sistema o historia completa.
- Bienestar del programador, se rige por la filosofía que un programador cansado, exhausto crea código de mala calidad, por eso se recomienda que los desarrolladores tengan 40 horas de trabajo a la semana y muy pocas horas extras de trabajo.
- Retroalimentación continua: Realización frecuente de pruebas y obtención de retroalimentación del cliente.
- Entregas pequeñas: El proyecto se divide en entregas cortas y frecuentes de software funcionando.
- Reunión diaria de equipo: Reuniones diarias para coordinación y solución de problemas.
- Retroalimentación continua: Realización frecuente de pruebas y obtención de retroalimentación del cliente.
- Entregas pequeñas: El proyecto se divide en entregas cortas y frecuentes de software funcionando.
- Reunión diaria de equipo:Reuniones diarias para coordinación y solución de problemas.
  
**Ventajas y desventajas de utilizar la metodología Programación extrema (XP):**

**Ventajas:**

- Entrega continua de software funcional. Permite detectar errores y obtener retroalimentación del cliente de manera temprana.
- Mayor flexibilidad a cambios. Al enfocarse en entregas pequeñas y iteraciones cortas, es más fácil adaptarse a cambios en los requerimientos
- Mayor calidad de código. Las prácticas como pair programming y testing continuos ayudan a mejorar la calidad.
- Aumenta la productividad. Las prácticas ágiles y el enfoque colaborativo en el equipo impulsan la productividad.
- Promueve el trabajo en equipo y buena comunicación. Los roles no están delimitados y se busca la colaboración.
 
**Desventajas**:

- Curva de aprendizaje empinada. Adoptar XP representa un cambio grande para equipos acostumbrados a metodologías tradicionales.
- Requiere de clientes involucrados. Si el cliente no participa activamente, XP no funciona bien.
- Difícil de escalar a proyectos muy grandes. XP se enfoca en equipos pequeños y metodologías livianas.
- Falta de énfasis en la arquitectura y diseño. Esto puede causar problemas en proyectos complejos.
- Depende en exceso de las habilidades técnicas del equipo de programadores.
 
**¿Cómo implementar esos principios en nuestro proyecto?**

- Los principios de agilidad identificados promueven equipos autoorganizados, colaboración con el cliente, entregas rápidas e incrementales, adaptabilidad a los cambios y mejora continua. Estos principios son claves en metodologías ágiles para lograr mayor eficiencia. La manera en la que implementaríamos los principios de agilidad sería de la siguiente manera:

- Formar equipos autoorganizados y multifuncionales, dándoles autonomía para tomar decisiones sobre cómo abordar el trabajo.
- Tener iteraciones cortas de 1 a 4 semanas para hacer entregas frecuentes de funcionalidad. Al final de cada iteración se entrega un incremento funcional del producto.
- Involucrar al cliente de manera activa, obteniendo su feedback frecuente sobre los incrementos entregados.
- Adaptar el plan del proyecto a medida que cambian los requisitos, en lugar de seguir un plan preestablecido rígidamente.
- Hacer reuniones diarias de equipo para coordinación e identificación temprana de problemas.
- Reducir la documentación al mínimo necesario, centrándose en código que funcione y aporte valor al cliente.
- Promover la simplicidad en el diseño y refactorización continua cuando sea necesario.  
- Crear un ambiente de trabajo colaborativo, motivador y productivo para el equipo.





# Referencias:

ACM y IEEE-CS (2020). Computing Curricula 2020: Paradigms for Global Computing Education. https://dl.acm.org/doi/book/10.1145/3467967

ANIEI Y CONAIC. (2017). Competencias transversales y específicas de los perfiles que evalúa CONAIC.

Abiztar. (n.d.). Especificaciones de Casos de Uso: lo que bien comienza, bien acaba. Com.mx. Recuperado el 13 de noviembre, 2023, de https://www.abiztar.com.mx/articulos/especificaciones-de-casos-de-uso.html

Chaves, A. & Universidad de Costa Rica. (2005). La ingeniería de requerimientos y su importancia en el desarrollo de proyectos de software. InterSedes: Revista de las Sedes Regionales, VI(10), 2215-2458. https://www.redalyc.org/pdf/666/66612870011.pdf

De la, C. de I. (n.d.). SABER. Revista Multidisciplinaria del. Redalyc.org. recuperado el 13 de noviembre, 2023, de https://www.redalyc.org/pdf/4277/427739430010.pdf

Foster, S. (2020). Software safety vs. Security: What’s the difference between safety and security? Recuperdado el 15 de noviembre, 2023, de https://www.perforce.com/blog/kw/software-safety-vs-security-whats-different

G. Rodríguez-Abitia, M. de Lourdes Sánchez-Guerrero, S. Martínez-Pérez y N. Aguas-García. (2022). "Competencies of Information Technology Professionals in Society 5.0, en IEEE Revista Iberoamericana de Tecnologías del Aprendizaje, vol. 17, no. 4, pp. 343-350, Nov. 2022, doi: 10.1109/RITA.2022.3217136.

G. Maigua, E. López, Buenas prácticas en la dirección y gestión de proyectos informáticos, Argentina: Editorial de la Universidad Tecnológica Nacional – edUTecNe, 2012, p.13.

Guest User. (2018, August 2). Historias de Usuario, Escritura, Definición, Contexto y Ejemplos — SCRUM MÉXICO. SCRUM MÉXICO. Recuperado el 13 de noviembre, 2023, de https://scrum.mx/informate/historias-de-usuario

Hurtado, Z., Elena, M., Espinosa, C., Oliver, E., Benguría, R., & Instituto Politécnico Nacional. (2019). El desarrollo de habilidades blandas en la formación de ingenieros. Científica, 23(1), 1665-0654. https://www.redalyc.org/journal/614/61458265007/61458265007.pdf

Rehkopf, D. M. (n.d.). Historias de usuario. Atlassian. Recuperado el 13 de noviembre, 2023, de https://www.atlassian.com/es/agile/project-management/user-stories

Sentrio. (2021, octubre 13). Metodologías Agile: los 4 valores y 12 principios del ‘Manifiesto Ágil’. Sentrio. https://sentrio.io/blog/valores-principios-agile-manifiesto-agil/

Synopsis (s.f.). Application security. Recuperado el 15 de noviembre de de https://www.synopsys.com/glossary/what-is-application-security.html

TFT. (2020). Software Safety Vs Security: What’s the difference? https://www.tftus.com/blog/software-safety-vs-security-whats-different

Edu.ar. Recuperado el 15 de noviembre de 2023, de http://sedici.unlp.edu.ar/bitstream/handle/10915/32172/Documento_completo__.pdf?sequence=1&isAllowed=y

Manifiesto por el Desarrollo Ágil de Software. (s/f). Agilemanifesto.org. Recuperado el 15 de noviembre, 2023, de https://agilemanifesto.org/iso/es/manifesto.html

Graván, A. D. (2018, noviembre 29). Manifiesto “agile”, ¿qué es? BBVA. Recuperado el 16 de noviembre, 2023, de https://www.bbva.com/es/innovacion/agile-manifiesto-que-es/

Y. O. Guntín y L. G. A. d. l. Campa (Tutor). Tesis de Grado. La Habana, Instituto Superior Politécnico José Antonio Echeverría. 2008.

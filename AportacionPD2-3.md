#### Métodos de prototipos evolutivos

Un modelo el cual permita la inclusión de pruebas constantes es el modelo de prototipos evolutivos, pues la UNAM (2012) define a este proceso como “la creación de una implementación parcial de un sistema, para el propósito explícito de aprender sobre los requerimientos del sistema”. Los prototipos se empiezan a crear a partir de la segunda fase principal del modelo y se busca crearlos de la manera más rápida posible, para después presentarlos a los clientes o representantes, los cuales lo probarán y retroalimentarán, devolviendo los errores que encuentren y  posteriormente el equipo desarrollador corrija estos errores para nuevamente presentar hasta haber cubierto los puntos débiles o fallas totales del sistema. 
En su libro electrónico “Metodologías y Procesos de Análisis de Software” la UNAM (2012) describe el proceso del modelo en 5 fases principales:
1. **Investigación preliminar:** Esta fase se divide a su vez en 3 fases: clasificación de requerimientos, estudio de factibilidad y la aprobación del requerimiento. Estas 3 sub-fases tienen como meta general determinar la problemática, el ámbito, identificar una idea general para la solución del problema y determinar si el sistema es o no factible de realizar
2. **Definición de requerimientos del sistema:** Una vez concluida la fase anterior y haberse determinado que el proyecto es viable, se avanza con la fase de la definición de los requerimientos, la cual a su vez se divide en otras 5 sub-fases. Es en esta fase donde comienzan las pruebas constantes para realizar el código; la fase comenzará con el análisis grueso y especificación; en esta primera sub-fase se crea el primer boceto del prototipo del sistema, luego pasamos a la sub-fase diseño y construcción, fase donde el boceto pasa a un software funcional listo para presentar como primera entrega. Le sigue la sub-fase de evaluación, parte donde el código se presenta a los usuarios para que ellos retroalimenten y el equipo desarrollador presente el código corregido. Casi para terminar sub-fase está la modificación, que es donde el código entra en corrección según los comentarios de los usuarios propuestos en la sub-fase anterior. La fase termina con el término, que es la sub-fase donde el código se presenta en su gran mayoría sin errores y con el visto bueno de los usuarios.
3. **Diseño técnico:** Es en esta fase donde se crea una interfaz para el programa en base a los estándares de la marca. La fase se centrará únicamente en crear un diseño detallado y sofisticado para el usuario en general; como adicional igual se crea una documentación que especifica las funciones del programa y lo necesario para realizar cualquier tipo de mantenimiento al software.
4. **Desarrollo y pruebas:** En esta fase ya se han tenido las pruebas suficientes para tener un programa completo, con un diseño digno de salir al mercado y una funcionalidad cómoda y correcta para el usuario, por lo que únicamente se realizarán unas últimas pruebas para confirmar que el código funcione en su totalidad, y en caso de presentarse algún inconveniente, corregirlo inmediatamente y poder entregar el código.
5. **Operación y mantenimiento:** Es la última fase del modelo; en esta fase los errores son mínimos y el programa ya se encuentra entregado al usuario, La fase queda únicamente como método preventivo en caso de fallas y un mantenimiento al software para evitar su caída.

   
**Ejemplo:** Al momento de entrar a la fase de diseño y empezar a trabajar con diagramas de casos de uso y wireframes nos guíamos únicamente por nuestra propia percepción, por lo que los wireframes no fueron lo más óptimos y cómodos para los usuarios; a raíz de un análisis del equipo nos metimos al papel de usuarios y pensamos en las funciones básicas que realizan los wireframes y la experiencia que estos generan; fue gracias a este análisis que nos dimos cuenta que no eran adecuados y empezamos una fase de prueba y error, creando, descartando y mejorando bocetos de diseños, llegando así hasta los últimos bocetos funcionales que dejamos como correctos.  Esto nos dejó una enseñanza a menor escala de lo que sucede en el modelo, sin embargo, se considera como una buena aproximación hacia lo que normalmente se trata con este modelo de prototipos.
